package main
import(
	"fmt"
    "reflect"
    "bytes"
    "net"
    "net/http"
    "net/url"
    "bufio"
    "strings"
    "strconv"
    "encoding/asn1"
    "encoding/json"
    "github.com/456vv/vmap/v2"
    "github.com/456vv/vconnpool"
    "github.com/456vv/vbody"
    "github.com/456vv/vcipher"
    "github.com/456vv/vweb"
    "regexp"
    "unicode"
    "unicode/utf8"
    "os"
    "io"
    "io/ioutil"
    "context"
    "time"
    "crypto"
    "crypto/aes"
    "crypto/cipher"
    "crypto/des"
    "crypto/dsa"
    "crypto/ecdsa"
    "crypto/elliptic"
    "crypto/hmac"
    "crypto/rand"
    "crypto/rsa"
    "crypto/tls"
    "crypto/x509"
    "crypto/x509/pkix"
    "crypto/sha1"
    "crypto/sha256"
    "crypto/sha512"
    "math/big"
    "unsafe"
    "path/filepath"
    "path"
   	"sync"
   	"sync/atomic"
   	"errors"
   	"log"
)

var dotFuncMap = map[string]map[string]interface{}{
	"vweb":{
		"ConfigSitePlugin":func(a ...interface{}) *vweb.ConfigSitePlugin {if len(a) == 0 {return new(vweb.ConfigSitePlugin)};inf:=a[0];if t, ok := inf.(*vweb.ConfigSitePlugin); ok {return t}else if t, ok := inf.(vweb.ConfigSitePlugin); ok {return &t};return (*vweb.ConfigSitePlugin)(nil)},
		"PluginHTTPClient":func(a ...interface{}) *vweb.PluginHTTPClient {if len(a) == 0 {return new(vweb.PluginHTTPClient)};inf:=a[0];if t, ok := inf.(*vweb.PluginHTTPClient); ok {return t}else if t, ok := inf.(vweb.PluginHTTPClient); ok {return &t};return (*vweb.PluginHTTPClient)(nil)},
		"ConfigPluginHTTPClient":vweb.ConfigPluginHTTPClient,
		"PluginRPCClient":func(a ...interface{}) *vweb.PluginRPCClient {if len(a) == 0 {return new(vweb.PluginRPCClient)};inf:=a[0];if t, ok := inf.(*vweb.PluginRPCClient); ok {return t}else if t, ok := inf.(vweb.PluginRPCClient); ok {return &t};return (*vweb.PluginRPCClient)(nil)},
		"ConfigPluginRPCClient":vweb.ConfigPluginRPCClient,
		"GenerateRandomId":vweb.GenerateRandomId,
		"GenerateRandom":vweb.GenerateRandom,
		"GenerateRandomString":vweb.GenerateRandomString,
		"AddSalt":vweb.AddSalt,
		"PagePath":vweb.PagePath,
		"Cookie":func(a ...interface{}) *vweb.Cookie {if len(a) == 0 {return new(vweb.Cookie)};inf:=a[0];if t, ok := inf.(*vweb.Cookie); ok {return t}else if t, ok := inf.(vweb.Cookie); ok {return &t};return (*vweb.Cookie)(nil)},
		"Session":func(a ...interface{}) *vweb.Session {if len(a) == 0 {return new(vweb.Session)};inf:=a[0];if t, ok := inf.(*vweb.Session); ok {return t}else if t, ok := inf.(vweb.Session); ok {return &t};return (*vweb.Session)(nil)},
		"NewSession":vweb.NewSession,
		"Sessions":func(a ...interface{}) *vweb.Sessions {if len(a) == 0 {return new(vweb.Sessions)};inf:=a[0];if t, ok := inf.(*vweb.Sessions); ok {return t}else if t, ok := inf.(vweb.Sessions); ok {return &t};return (*vweb.Sessions)(nil)},
		"SitePool":func(a ...interface{}) *vweb.SitePool {if len(a) == 0 {return new(vweb.SitePool)};inf:=a[0];if t, ok := inf.(*vweb.SitePool); ok {return t}else if t, ok := inf.(vweb.SitePool); ok {return &t};return (*vweb.SitePool)(nil)},
		"NewSitePool":vweb.NewSitePool,
		"Site":func(a ...interface{}) *vweb.Site {if len(a) == 0 {return new(vweb.Site)};inf:=a[0];if t, ok := inf.(*vweb.Site); ok {return t}else if t, ok := inf.(vweb.Site); ok {return &t};return (*vweb.Site)(nil)},
		"NewSite":vweb.NewSite,
		"Sites":func(a ...interface{}) *vweb.Sites {if len(a) == 0 {return new(vweb.Sites)};inf:=a[0];if t, ok := inf.(*vweb.Sites); ok {return t}else if t, ok := inf.(vweb.Sites); ok {return &t};return (*vweb.Sites)(nil)},
		"NewSites":vweb.NewSites,
		"ServerHandlerStatic":func(a ...interface{}) *vweb.ServerHandlerStatic {if len(a) == 0 {return new(vweb.ServerHandlerStatic)};inf:=a[0];if t, ok := inf.(*vweb.ServerHandlerStatic); ok {return t}else if t, ok := inf.(vweb.ServerHandlerStatic); ok {return &t};return (*vweb.ServerHandlerStatic)(nil)},
		"ServerHandlerDynamic":func(a ...interface{}) *vweb.ServerHandlerDynamic {if len(a) == 0 {return new(vweb.ServerHandlerDynamic)};inf:=a[0];if t, ok := inf.(*vweb.ServerHandlerDynamic); ok {return t}else if t, ok := inf.(vweb.ServerHandlerDynamic); ok {return &t};return (*vweb.ServerHandlerDynamic)(nil)},
	},
	"vconnpool":{
		"ConnPool":func(a ...interface{}) *vconnpool.ConnPool {if len(a) == 0 {return new(vconnpool.ConnPool)};inf:=a[0];if t, ok := inf.(*vconnpool.ConnPool); ok {return t}else if t, ok := inf.(vconnpool.ConnPool); ok {return &t};return (*vconnpool.ConnPool)(nil)},
	},
	"vbody":{
		"NewReader":vbody.NewReader,
		"NewWriter":vbody.NewWriter,
	},
	"vcipher":{
		"AES":vcipher.AES,
		"NewCipher":vcipher.NewCipher,
	},
	"vmap":{
		"NewMap":vmap.NewMap,
	},
	"errors":{
		"As":errors.As,
		"Is":errors.Is,
		"New":errors.New,
		"Unwrap":errors.Unwrap,
	},
	"sync":{
		"Map":func(a ...interface{}) *sync.Map {if len(a) == 0 {return new(sync.Map)};inf:=a[0];if t, ok := inf.(*sync.Map); ok {return t}else if t, ok := inf.(sync.Map); ok {return &t};return (*sync.Map)(nil)},
	},
	"sync/atomic":{
		"AddInt32":atomic.AddInt32,
		"AddInt64":atomic.AddInt64,
		"AddUint32":atomic.AddUint32,
		"AddUint64":atomic.AddUint64,
		"AddUintptr":atomic.AddUintptr,
		"CompareAndSwapInt32":atomic.CompareAndSwapInt32,
		"CompareAndSwapInt64":atomic.CompareAndSwapInt64,
		"CompareAndSwapPointer":atomic.CompareAndSwapPointer,
		"CompareAndSwapUint32":atomic.CompareAndSwapUint32,
		"CompareAndSwapUint64":atomic.CompareAndSwapUint64,
		"CompareAndSwapUintptr":atomic.CompareAndSwapUintptr,
		"LoadInt32":atomic.LoadInt32,
		"LoadInt64":atomic.LoadInt64,
		"LoadPointer":atomic.LoadPointer,
		"LoadUint32":atomic.LoadUint32,
		"LoadUint64":atomic.LoadUint64,
		"LoadUintptr":atomic.LoadUintptr,
		"StoreInt32":atomic.StoreInt32,
		"StoreInt64":atomic.StoreInt64,
		"StorePointer":atomic.StorePointer,
		"StoreUint32":atomic.StoreUint32,
		"StoreUint64":atomic.StoreUint64,
		"StoreUintptr":atomic.StoreUintptr,
		"SwapInt32":atomic.SwapInt32,
		"SwapInt64":atomic.SwapInt64,
		"SwapPointer":atomic.SwapPointer,
		"SwapUint32":atomic.SwapUint32,
		"SwapUint64":atomic.SwapUint64,
		"SwapUintptr":atomic.SwapUintptr,
		"Value":func(a ...interface{}) *atomic.Value {if len(a) == 0 {return new(atomic.Value)};inf:=a[0];if t, ok := inf.(*atomic.Value); ok {return t}else if t, ok := inf.(atomic.Value); ok {return &t};return (*atomic.Value)(nil)},
	},
	"path":{
		"Base":path.Base,
		"Clean":path.Clean,
		"Dir":path.Dir,
		"Ext":path.Ext,
		"IsAbs":path.IsAbs,
		"Join":path.Join,
		"Split":path.Split,
		"Match":path.Match,
	},
	"path/filepath":{
		"Separator":filepath.Separator,
		"ListSeparator":filepath.ListSeparator,
		"Abs":filepath.Abs,
		"Rel":filepath.Rel,
		"Base":filepath.Base,
		"Clean":filepath.Clean,
		"Dir":filepath.Dir,
		"EvalSymlinks":filepath.EvalSymlinks,
		"Ext":filepath.Ext,
		"FromSlash":filepath.FromSlash,
		"ToSlash":filepath.ToSlash,
		"Glob":filepath.Glob,
		"HasPrefix":filepath.HasPrefix,
		"IsAbs":filepath.IsAbs,
		"Join":filepath.Join,
		"Match":filepath.Match,
		"Split":filepath.Split,
		"SplitList":filepath.SplitList,
		"VolumeName":filepath.VolumeName,
	},
	"fmt":{
		"Errorf":fmt.Errorf,
		"Fprint":fmt.Fprint,
		"Fprintf":fmt.Fprintf,
		"Fprintln":fmt.Fprintln,
		"Sprint":fmt.Sprint,
		"Sprintf":fmt.Sprintf,
		"Sprintln":fmt.Sprintln,
	},
    "reflect":{
        "Copy":reflect.Copy,
        "DeepEqual":reflect.DeepEqual,
        "Select":reflect.Select,
        "Swapper":reflect.Swapper,
		"ChanDir":func(ChanDir int) reflect.ChanDir {return reflect.ChanDir(ChanDir)},
        "RecvDir":reflect.RecvDir,
        "SendDir":reflect.SendDir,
        "BothDir":reflect.BothDir,
		"Kind":func(Kind uint) reflect.Kind {return reflect.Kind(Kind)},
        "Invalid":reflect.Invalid,
        "Bool":reflect.Bool,
        "Int":reflect.Int,
        "Int8":reflect.Int8,
        "Int16":reflect.Int16,
        "Int32":reflect.Int32,
        "Int64":reflect.Int64,
        "Uint":reflect.Uint,
        "Uint8":reflect.Uint8,
        "Uint16":reflect.Uint16,
        "Uint32":reflect.Uint32,
        "Uint64":reflect.Uint64,
        "Uintptr":reflect.Uintptr,
        "Float32":reflect.Float32,
        "Float64":reflect.Float64,
        "Complex64":reflect.Complex64,
        "Complex128":reflect.Complex128,
        "Array":reflect.Array,
        "Chan":reflect.Chan,
        "Func":reflect.Func,
        "Interface":reflect.Interface,
        "Map":reflect.Map,
        "Ptr":reflect.Ptr,
        "Slice":reflect.Slice,
        "String":reflect.String,
        "Struct":reflect.Struct,
        "UnsafePointer":reflect.UnsafePointer,
		"Method":func(a ...interface{}) *reflect.Method {if len(a) == 0 {return new(reflect.Method)};inf:=a[0];if t, ok := inf.(*reflect.Method); ok {return t}else if t, ok := inf.(reflect.Method); ok {return &t};return (*reflect.Method)(nil)},
		"SelectCase":func(a ...interface{}) *reflect.SelectCase {if len(a) == 0 {return new(reflect.SelectCase)};inf:=a[0];if t, ok := inf.(*reflect.SelectCase); ok {return t}else if t, ok := inf.(reflect.SelectCase); ok {return &t};return (*reflect.SelectCase)(nil)},
		"SelectDir":func(SelectDir int) reflect.SelectDir {return reflect.SelectDir(SelectDir)},
		"SelectSend":reflect.SelectSend,
		"SelectRecv":reflect.SelectRecv,
		"SelectDefault":reflect.SelectDefault,
		"SliceHeader":func(a ...interface{}) *reflect.SliceHeader {if len(a) == 0 {return new(reflect.SliceHeader)};inf:=a[0];if t, ok := inf.(*reflect.SliceHeader); ok {return t}else if t, ok := inf.(reflect.SliceHeader); ok {return &t};return (*reflect.SliceHeader)(nil)},
		"StringHeader":func(a ...interface{}) *reflect.StringHeader {if len(a) == 0 {return new(reflect.StringHeader)};inf:=a[0];if t, ok := inf.(*reflect.StringHeader); ok {return t}else if t, ok := inf.(reflect.StringHeader); ok {return &t};return (*reflect.StringHeader)(nil)},
		"StructField":func(a ...interface{}) *reflect.StructField {if len(a) == 0 {return new(reflect.StructField)};inf:=a[0];if t, ok := inf.(*reflect.StructField); ok {return t}else if t, ok := inf.(reflect.StructField); ok {return &t};return (*reflect.StructField)(nil)},
		"StructTag":func(StructTag string) reflect.StructTag {return reflect.StructTag(StructTag)},
		"ArrayOf":reflect.ArrayOf,
        "ChanOf":reflect.ChanOf,
        "FuncOf":reflect.FuncOf,
        "MapOf":reflect.MapOf,
        "PtrTo":reflect.PtrTo,
        "SliceOf":reflect.SliceOf,
        "StructOf":reflect.StructOf,
        "TypeOf":reflect.TypeOf,
		"Value":func(a ...interface{}) *reflect.Value {if len(a) == 0 {return new(reflect.Value)};inf:=a[0];if t, ok := inf.(*reflect.Value); ok {return t}else if t, ok := inf.(reflect.Value); ok {return &t};return (*reflect.Value)(nil)},
        "Append":reflect.Append,
        "AppendSlice":reflect.AppendSlice,
        "Indirect":reflect.Indirect,
        "MakeChan":reflect.MakeChan,
        "MakeFunc":reflect.MakeFunc,
        "MakeMap":reflect.MakeMap,
        "MakeMapWithSize":reflect.MakeMapWithSize,
        "MakeSlice":reflect.MakeSlice,
        "New":reflect.New,
        "NewAt":reflect.NewAt,
        "ValueOf":reflect.ValueOf,
        "Zero":reflect.Zero,
    },
    "unsafe":{
    	"Uintptr":func(Pointer unsafe.Pointer) uintptr {return uintptr(Pointer)},
		"Pointer":func(Pointer uintptr) unsafe.Pointer {return unsafe.Pointer(Pointer)},
		"Alignof":func(Pointer uintptr) uintptr {return unsafe.Alignof(Pointer)},
		"Sizeof":func(Pointer uintptr) uintptr {return unsafe.Sizeof(Pointer)},
    },
    "context":{
		"CancelFunc":func(CancelFunc func()) context.CancelFunc {return context.CancelFunc(CancelFunc)},
    	"Background":context.Background,
    	"TODO":context.TODO,
    	"WithCancel":context.WithCancel,
    	"WithDeadline":context.WithDeadline,
    	"WithTimeout":context.WithTimeout,
    	"WithValue":context.WithValue,
    },
    "time":{
		"ANSIC":time.ANSIC,
		"UnixDate":time.UnixDate,
		"RubyDate":time.RubyDate,
		"RFC822":time.RFC822,
		"RFC822Z":time.RFC822Z,
		"RFC850":time.RFC850,
		"RFC1123":time.RFC1123,
		"RFC1123Z":time.RFC1123Z,
		"RFC3339":time.RFC3339,
		"RFC3339Nano":time.RFC3339Nano,
		"Kitchen":time.Kitchen,
		"Stamp":time.Stamp,
		"StampMilli":time.StampMilli,
		"StampMicro":time.StampMicro,
		"StampNano":time.StampNano,
		"Duration":func(Duration int64) time.Duration {return time.Duration(Duration)},
		"Nanosecond":time.Nanosecond,
		"Microsecond":time.Microsecond,
		"Millisecond":time.Millisecond,
		"Second":time.Second,
		"Minute":time.Minute,
		"Hour":time.Hour,
		"After":time.After,
		"Sleep":time.Sleep,
		"Tick":time.Tick,
		"ParseDuration":time.ParseDuration,
		"Since":time.Since,
		"Until":time.Until,
		"Location":func(a ...interface{}) *time.Location {if len(a) == 0 {return new(time.Location)};inf:=a[0];if t, ok := inf.(*time.Location); ok {return t}else if t, ok := inf.(time.Location); ok {return &t};return (*time.Location)(nil)},
		"Local":time.Local,
		"UTC":time.UTC,
		"FixedZone":time.FixedZone,
		"LoadLocation":time.LoadLocation,
		"LoadLocationFromTZData":time.LoadLocationFromTZData,
		"Month":func(Month int) time.Month {return time.Month(Month)},
		"Ticker":func(a ...interface{}) *time.Ticker {if len(a) == 0 {return new(time.Ticker)};inf:=a[0];if t, ok := inf.(*time.Ticker); ok {return t}else if t, ok := inf.(time.Ticker); ok {return &t};return (*time.Ticker)(nil)},
		"NewTicker":time.NewTicker,
		"Time":func(a ...interface{}) *time.Time {if len(a) == 0 {return new(time.Time)};inf:=a[0];if t, ok := inf.(*time.Time); ok {return t}else if t, ok := inf.(time.Time); ok {return &t};return (*time.Time)(nil)},
		"Date":time.Date,
		"Now":time.Now,
		"Parse":time.Parse,
		"ParseInLocation":time.ParseInLocation,
		"Unix":time.Unix,
		"Timer":func(a ...interface{}) *time.Timer {if len(a) == 0 {return new(time.Timer)};inf:=a[0];if t, ok := inf.(*time.Timer); ok {return t}else if t, ok := inf.(time.Timer); ok {return &t};return (*time.Timer)(nil)},
		"AfterFunc":time.AfterFunc,
		"NewTimer":time.NewTimer,
		"Weekday":func(Weekday int) time.Weekday {return time.Weekday(Weekday)},
    },
    "net":{
		"DefaultResolver":net.DefaultResolver,
		"InterfaceAddrs":net.InterfaceAddrs,
		"Interfaces":net.Interfaces,
		"JoinHostPort":net.JoinHostPort,
		"LookupAddr":net.LookupAddr,
		"LookupCNAME":net.LookupCNAME,
		"LookupHost":net.LookupHost,
		"LookupIP":net.LookupIP,
		"LookupMX":net.LookupMX,
		"LookupNS":net.LookupNS,
		"LookupPort":net.LookupPort,
		"LookupSRV":net.LookupSRV,
		"LookupTXT":net.LookupTXT,
		"SplitHostPort":net.SplitHostPort,
		"Buffers":func(Buffers [][]byte) net.Buffers {return Buffers},
		"Dial":net.Dial,
		"DialTimeout":net.DialTimeout,
		"Dialer":func(a ...interface{}) *net.Dialer {if len(a) == 0 {return new(net.Dialer)};inf:=a[0];if t, ok := inf.(*net.Dialer); ok {return t}else if t, ok := inf.(net.Dialer); ok {return &t};return (*net.Dialer)(nil)},
		"Flags":func(Flags uint) net.Flags {return net.Flags(Flags)},
		"HardwareAddr":func(HardwareAddr []byte) net.HardwareAddr {return HardwareAddr},
		"ParseMAC":net.ParseMAC,
		"IP":func(IP []byte) net.IP {return IP},
		"IPv4":net.IPv4,
		"ParseCIDR":net.ParseCIDR,
		"ParseIP":net.ParseIP,
		"IPAddr":func(a ...interface{}) *net.IPAddr {if len(a) == 0 {return new(net.IPAddr)};inf:=a[0];if t, ok := inf.(*net.IPAddr); ok {return t}else if t, ok := inf.(net.IPAddr); ok {return &t};return (*net.IPAddr)(nil)},
		"ResolveIPAddr":net.ResolveIPAddr,
		"IPConn":func(a ...interface{}) *net.IPConn {if len(a) == 0 {return new(net.IPConn)};inf:=a[0];if t, ok := inf.(*net.IPConn); ok {return t}else if t, ok := inf.(net.IPConn); ok {return &t};return (*net.IPConn)(nil)},
		"DialIP":net.DialIP,
		"IPMask":func(IPMask []byte) net.IPMask {return IPMask},
		"CIDRMask":net.CIDRMask,
		"IPv4Mask":net.IPv4Mask,
		"IPNet":func(a ...interface{}) *net.IPNet {if len(a) == 0 {return new(net.IPNet)};inf:=a[0];if t, ok := inf.(*net.IPNet); ok {return t}else if t, ok := inf.(net.IPNet); ok {return &t};return (*net.IPNet)(nil)},
		"Interface":func(a ...interface{}) *net.Interface {if len(a) == 0 {return new(net.Interface)};inf:=a[0];if t, ok := inf.(*net.Interface); ok {return t}else if t, ok := inf.(net.Interface); ok {return &t};return (*net.Interface)(nil)},
		"InterfaceByIndex":net.InterfaceByIndex,
		"InterfaceByName":net.InterfaceByName,
		"MX":func(a ...interface{}) *net.MX {if len(a) == 0 {return new(net.MX)};inf:=a[0];if t, ok := inf.(*net.MX); ok {return t}else if t, ok := inf.(net.MX); ok {return &t};return (*net.MX)(nil)},
		"NS":func(a ...interface{}) *net.NS {if len(a) == 0 {return new(net.NS)};inf:=a[0];if t, ok := inf.(*net.NS); ok {return t}else if t, ok := inf.(net.NS); ok {return &t};return (*net.NS)(nil)},
		"Resolver":func(a ...interface{}) *net.Resolver {if len(a) == 0 {return new(net.Resolver)};inf:=a[0];if t, ok := inf.(*net.Resolver); ok {return t}else if t, ok := inf.(net.Resolver); ok {return &t};return (*net.Resolver)(nil)},
		"SRV":func(a ...interface{}) *net.SRV {if len(a) == 0 {return new(net.SRV)};inf:=a[0];if t, ok := inf.(*net.SRV); ok {return t}else if t, ok := inf.(net.SRV); ok {return &t};return (*net.SRV)(nil)},
		"TCPAddr":func(a ...interface{}) *net.TCPAddr {if len(a) == 0 {return new(net.TCPAddr)};inf:=a[0];if t, ok := inf.(*net.TCPAddr); ok {return t}else if t, ok := inf.(net.TCPAddr); ok {return &t};return (*net.TCPAddr)(nil)},
		"ResolveTCPAddr":net.ResolveTCPAddr,
		"TCPConn":func(a ...interface{}) *net.TCPConn {if len(a) == 0 {return new(net.TCPConn)};inf:=a[0];if t, ok := inf.(*net.TCPConn); ok {return t}else if t, ok := inf.(net.TCPConn); ok {return &t};return (*net.TCPConn)(nil)},
		"DialTCP":net.DialTCP,
		"UDPAddr":func(a ...interface{}) *net.UDPAddr {if len(a) == 0 {return new(net.UDPAddr)};inf:=a[0];if t, ok := inf.(*net.UDPAddr); ok {return t}else if t, ok := inf.(net.UDPAddr); ok {return &t};return (*net.UDPAddr)(nil)},
		"ResolveUDPAddr":net.ResolveUDPAddr,
		"UDPConn":func(a ...interface{}) *net.UDPConn {if len(a) == 0 {return new(net.UDPConn)};inf:=a[0];if t, ok := inf.(*net.UDPConn); ok {return t}else if t, ok := inf.(net.UDPConn); ok {return &t};return (*net.UDPConn)(nil)},
		"DialUDP":net.DialUDP,
		"ListenMulticastUDP":net.ListenMulticastUDP,
 		"ListenUDP":net.ListenUDP,
   },
	"net/http":{
		"LocalAddrContextKey":http.LocalAddrContextKey,
		"ServerContextKey":http.ServerContextKey,
		"NoBody":http.NoBody,
		"DefaultClient":http.DefaultClient,
		"DefaultTransport":http.DefaultTransport,
		"Client":func(a ...interface{}) *http.Client {if len(a) == 0 {return new(http.Client)};inf:=a[0];if t, ok := inf.(*http.Client); ok {return t}else if t, ok := inf.(http.Client); ok {return &t};return (*http.Client)(nil)},
		"ConnState":func(ConnState int) http.ConnState {return http.ConnState(ConnState)},
		"Cookie":func(a ...interface{}) *http.Cookie {if len(a) == 0 {return new(http.Cookie)};inf:=a[0];if t, ok := inf.(*http.Cookie); ok {return t}else if t, ok := inf.(http.Cookie); ok {return &t};return (*http.Cookie)(nil)},
		"SameSite":func(SameSite int) http.SameSite {return http.SameSite(SameSite)},
		"Header":func(a ...interface{}) *http.Header {if len(a) == 0 {return new(http.Header)};inf:=a[0];if t, ok := inf.(*http.Header); ok {return t}else if t, ok := inf.(http.Header); ok {return &t};return (*http.Header)(nil)},
		"PushOptions":func(a ...interface{}) *http.PushOptions {if len(a) == 0 {return new(http.PushOptions)};inf:=a[0];if t, ok := inf.(*http.PushOptions); ok {return t}else if t, ok := inf.(http.PushOptions); ok {return &t};return (*http.PushOptions)(nil)},
		"Request":func(a ...interface{}) *http.Request {if len(a) == 0 {return new(http.Request)};inf:=a[0];if t, ok := inf.(*http.Request); ok {return t}else if t, ok := inf.(http.Request); ok {return &t};return (*http.Request)(nil)},
		"NewRequest":http.NewRequest,
		"ReadRequest":http.ReadRequest,
		"Response":func(a ...interface{}) *http.Response {if len(a) == 0 {return new(http.Response)};inf:=a[0];if t, ok := inf.(*http.Response); ok {return t}else if t, ok := inf.(http.Response); ok {return &t};return (*http.Response)(nil)},
		"Get":http.Get,
		"Head":http.Head,
		"Post":http.Post,
		"PostForm":http.PostForm,
		"ReadResponse":http.ReadResponse,
		"Transport":func(a ...interface{}) *http.Transport {if len(a) == 0 {return new(http.Transport)};inf:=a[0];if t, ok := inf.(*http.Transport); ok {return t}else if t, ok := inf.(http.Transport); ok {return &t};return (*http.Transport)(nil)},
	},
	"crypto":{
		"RegisterHash":crypto.RegisterHash,
		"Hash":func(Hash int) crypto.Hash {return crypto.Hash(Hash)},
	},
	"crypto/aes":{
		"NewCipher":aes.NewCipher,
	},
	"crypto/des":{
		"NewCipher":des.NewCipher,
		"NewTripleDESCipher":des.NewTripleDESCipher,
	},
	"crypto/dsa":{
		"GenerateKey":dsa.GenerateKey,
		"GenerateParameters":dsa.GenerateParameters,
		"Sign":dsa.Sign,
		"Verify":dsa.Verify,
		"ParameterSizes":func(ParameterSizes int) dsa.ParameterSizes {return dsa.ParameterSizes(ParameterSizes)},
		"Parameters":func(a ...interface{}) *dsa.Parameters {if len(a) == 0 {return new(dsa.Parameters)};inf:=a[0];if t, ok := inf.(*dsa.Parameters); ok {return t}else if t, ok := inf.(dsa.Parameters); ok {return &t};return (*dsa.Parameters)(nil)},
		"PrivateKey":func(a ...interface{}) *dsa.PrivateKey {if len(a) == 0 {return new(dsa.PrivateKey)};inf:=a[0];if t, ok := inf.(*dsa.PrivateKey); ok {return t}else if t, ok := inf.(dsa.PrivateKey); ok {return &t};return (*dsa.PrivateKey)(nil)},
		"PublicKey":func(a ...interface{}) *dsa.PublicKey {if len(a) == 0 {return new(dsa.PublicKey)};inf:=a[0];if t, ok := inf.(*dsa.PublicKey); ok {return t}else if t, ok := inf.(dsa.PublicKey); ok {return &t};return (*dsa.PublicKey)(nil)},
	},
	"crypto/rsa":{
		"DecryptOAEP":rsa.DecryptOAEP,
		"DecryptPKCS1v15":rsa.DecryptPKCS1v15,
		"DecryptPKCS1v15SessionKey":rsa.DecryptPKCS1v15SessionKey,
		"EncryptOAEP":rsa.EncryptOAEP,
		"EncryptPKCS1v15":rsa.EncryptPKCS1v15,
		"SignPKCS1v15":rsa.SignPKCS1v15,
		"SignPSS":rsa.SignPSS,
		"VerifyPKCS1v15":rsa.VerifyPKCS1v15,
		"VerifyPSS":rsa.VerifyPSS,
		"CRTValue":func(a ...interface{}) *rsa.CRTValue {if len(a) == 0 {return new(rsa.CRTValue)};inf:=a[0];if t, ok := inf.(*rsa.CRTValue); ok {return t}else if t, ok := inf.(rsa.CRTValue); ok {return &t};return (*rsa.CRTValue)(nil)},
		"OAEPOptions":func(a ...interface{}) *rsa.OAEPOptions {if len(a) == 0 {return new(rsa.OAEPOptions)};inf:=a[0];if t, ok := inf.(*rsa.OAEPOptions); ok {return t}else if t, ok := inf.(rsa.OAEPOptions); ok {return &t};return (*rsa.OAEPOptions)(nil)},
		"PKCS1v15DecryptOptions":func(a ...interface{}) *rsa.PKCS1v15DecryptOptions {if len(a) == 0 {return new(rsa.PKCS1v15DecryptOptions)};inf:=a[0];if t, ok := inf.(*rsa.PKCS1v15DecryptOptions); ok {return t}else if t, ok := inf.(rsa.PKCS1v15DecryptOptions); ok {return &t};return (*rsa.PKCS1v15DecryptOptions)(nil)},
		"PSSOptions":func(a ...interface{}) *rsa.PSSOptions {if len(a) == 0 {return new(rsa.PSSOptions)};inf:=a[0];if t, ok := inf.(*rsa.PSSOptions); ok {return t}else if t, ok := inf.(rsa.PSSOptions); ok {return &t};return (*rsa.PSSOptions)(nil)},
		"PrecomputedValues":func(a ...interface{}) *rsa.PrecomputedValues {if len(a) == 0 {return new(rsa.PrecomputedValues)};inf:=a[0];if t, ok := inf.(*rsa.PrecomputedValues); ok {return t}else if t, ok := inf.(rsa.PrecomputedValues); ok {return &t};return (*rsa.PrecomputedValues)(nil)},
		"PrivateKey":func(a ...interface{}) *rsa.PrivateKey {if len(a) == 0 {return new(rsa.PrivateKey)};inf:=a[0];if t, ok := inf.(*rsa.PrivateKey); ok {return t}else if t, ok := inf.(rsa.PrivateKey); ok {return &t};return (*rsa.PrivateKey)(nil)},
		"GenerateKey":rsa.GenerateKey,
		"GenerateMultiPrimeKey":rsa.GenerateMultiPrimeKey,
		"PublicKey":func(a ...interface{}) *rsa.PublicKey {if len(a) == 0 {return new(rsa.PublicKey)};inf:=a[0];if t, ok := inf.(*rsa.PublicKey); ok {return t}else if t, ok := inf.(rsa.PublicKey); ok {return &t};return (*rsa.PublicKey)(nil)},
	},
	"crypto/ecdsa":{
		"Sign":ecdsa.Sign,
		"Verify":ecdsa.Verify,
		"GenerateKey":ecdsa.GenerateKey,
		"PrivateKey":func(a ...interface{}) *ecdsa.PrivateKey {if len(a) == 0 {return new(ecdsa.PrivateKey)};inf:=a[0];if t, ok := inf.(*ecdsa.PrivateKey); ok {return t}else if t, ok := inf.(ecdsa.PrivateKey); ok {return &t};return (*ecdsa.PrivateKey)(nil)},
		"PublicKey":func(a ...interface{}) *ecdsa.PublicKey {if len(a) == 0 {return new(ecdsa.PublicKey)};inf:=a[0];if t, ok := inf.(*ecdsa.PublicKey); ok {return t}else if t, ok := inf.(ecdsa.PublicKey); ok {return &t};return (*ecdsa.PublicKey)(nil)},
	},
	"crypto/elliptic":{
		"GenerateKey":elliptic.GenerateKey,
		"Marshal":elliptic.Marshal,
		"Unmarshal":elliptic.Unmarshal,
		"P224":elliptic.P224,
		"P256":elliptic.P256,
		"P384":elliptic.P384,
		"P521":elliptic.P521,
		"CurveParams":func(a ...interface{}) *elliptic.CurveParams {if len(a) == 0 {return new(elliptic.CurveParams)};inf:=a[0];if t, ok := inf.(*elliptic.CurveParams); ok {return t}else if t, ok := inf.(elliptic.CurveParams); ok {return &t};return (*elliptic.CurveParams)(nil)},
	},
	"crypto/hmac":{
		"Equal":hmac.Equal,
		"New":hmac.New,
	},
	"crypto/rand":{
		"Reader":rand.Reader,
		"Int":rand.Int,
		"Prime":rand.Prime,
		"Read":rand.Read,
	},
	"crypto/cipher":{
		"NewGCMWithTagSize":cipher.NewGCMWithTagSize,
		"NewGCM":cipher.NewGCM,
		"NewGCMWithNonceSize":cipher.NewGCMWithNonceSize,
		"NewCBCDecrypter":cipher.NewCBCDecrypter,
		"NewCBCEncrypter":cipher.NewCBCEncrypter,
		"NewCFBDecrypter":cipher.NewCFBDecrypter,
		"NewCFBEncrypter":cipher.NewCFBEncrypter,
		"NewCTR":cipher.NewCTR,
		"NewOFB":cipher.NewOFB,
		"StreamReader":func(a ...interface{}) *cipher.StreamReader {if len(a) == 0 {return new(cipher.StreamReader)};inf:=a[0];if t, ok := inf.(*cipher.StreamReader); ok {return t}else if t, ok := inf.(cipher.StreamReader); ok {return &t};return (*cipher.StreamReader)(nil)},
		"StreamWriter":func(a ...interface{}) *cipher.StreamWriter {if len(a) == 0 {return new(cipher.StreamWriter)};inf:=a[0];if t, ok := inf.(*cipher.StreamWriter); ok {return t}else if t, ok := inf.(cipher.StreamWriter); ok {return &t};return (*cipher.StreamWriter)(nil)},
	},
	"crypto/tls":{
		"Certificate":func(a ...interface{}) *tls.Certificate {if len(a) == 0 {return new(tls.Certificate)};inf:=a[0];if t, ok := inf.(*tls.Certificate); ok {return t}else if t, ok := inf.(tls.Certificate); ok {return &t};return (*tls.Certificate)(nil)},
		"LoadX509KeyPair":tls.LoadX509KeyPair,
		"X509KeyPair":tls.X509KeyPair,
		"CertificateRequestInfo":func(a ...interface{}) *tls.CertificateRequestInfo {if len(a) == 0 {return new(tls.CertificateRequestInfo)};inf:=a[0];if t, ok := inf.(*tls.CertificateRequestInfo); ok {return t}else if t, ok := inf.(tls.CertificateRequestInfo); ok {return &t};return (*tls.CertificateRequestInfo)(nil)},
		"ClientAuthType":func(ClientAuthType int) tls.ClientAuthType {return tls.ClientAuthType(ClientAuthType)},
		"ClientHelloInfo":func(a ...interface{}) *tls.ClientHelloInfo {if len(a) == 0 {return new(tls.ClientHelloInfo)};inf:=a[0];if t, ok := inf.(*tls.ClientHelloInfo); ok {return t}else if t, ok := inf.(tls.ClientHelloInfo); ok {return &t};return (*tls.ClientHelloInfo)(nil)},
		"NewLRUClientSessionCache":tls.NewLRUClientSessionCache,
		"ClientSessionState":func(a ...interface{}) *tls.ClientSessionState {if len(a) == 0 {return new(tls.ClientSessionState)};inf:=a[0];if t, ok := inf.(*tls.ClientSessionState); ok {return t}else if t, ok := inf.(tls.ClientSessionState); ok {return &t};return (*tls.ClientSessionState)(nil)},
		"Config":func(a ...interface{}) *tls.Config {if len(a) == 0 {return new(tls.Config)};inf:=a[0];if t, ok := inf.(*tls.Config); ok {return t}else if t, ok := inf.(tls.Config); ok {return &t};return (*tls.Config)(nil)},
		"Conn":func(a ...interface{}) *tls.Conn {if len(a) == 0 {return new(tls.Conn)};inf:=a[0];if t, ok := inf.(*tls.Conn); ok {return t}else if t, ok := inf.(tls.Conn); ok {return &t};return (*tls.Conn)(nil)},
		"Client":tls.Client,
		"Dial":tls.Dial,
		"DialWithDialer":tls.DialWithDialer,
		"ConnectionState":func(a ...interface{}) *tls.ConnectionState {if len(a) == 0 {return new(tls.ConnectionState)};inf:=a[0];if t, ok := inf.(*tls.ConnectionState); ok {return t}else if t, ok := inf.(tls.ConnectionState); ok {return &t};return (*tls.ConnectionState)(nil)},
		"CurveID":func(CurveID uint16) tls.CurveID {return tls.CurveID(CurveID)},
		"RenegotiationSupport":func(RenegotiationSupport int) tls.RenegotiationSupport {return tls.RenegotiationSupport(RenegotiationSupport)},
		"SignatureScheme":func(SignatureScheme uint16) tls.SignatureScheme {return tls.SignatureScheme(SignatureScheme)},
   	},
   	"crypto/x509":{
		"CreateCertificate":x509.CreateCertificate,
		"CreateCertificateRequest":x509.CreateCertificateRequest,
		"DecryptPEMBlock":x509.DecryptPEMBlock,
		"EncryptPEMBlock":x509.EncryptPEMBlock,
		"IsEncryptedPEMBlock":x509.IsEncryptedPEMBlock,
		"MarshalECPrivateKey":x509.MarshalECPrivateKey,
		"MarshalPKCS1PublicKey":x509.MarshalPKCS1PublicKey,
		"MarshalPKCS1PrivateKey":x509.MarshalPKCS1PrivateKey,
		"MarshalPKIXPublicKey":x509.MarshalPKIXPublicKey,
		"MarshalPKCS8PrivateKey":x509.MarshalPKCS8PrivateKey,
		"ParseCRL":x509.ParseCRL,
		"ParseCertificates":x509.ParseCertificates,
		"ParseDERCRL":x509.ParseDERCRL,
		"ParseECPrivateKey":x509.ParseECPrivateKey,
		"ParsePKCS1PublicKey":x509.ParsePKCS1PublicKey,
		"ParsePKCS1PrivateKey":x509.ParsePKCS1PrivateKey,
		"ParsePKCS8PrivateKey":x509.ParsePKCS8PrivateKey,
		"ParsePKIXPublicKey":x509.ParsePKIXPublicKey,
		"CertPool":func(a ...interface{}) *x509.CertPool {if len(a) == 0 {return new(x509.CertPool)};inf:=a[0];if t, ok := inf.(*x509.CertPool); ok {return t}else if t, ok := inf.(x509.CertPool); ok {return &t};return (*x509.CertPool)(nil)},
		"NewCertPool":x509.NewCertPool,
		"SystemCertPool":x509.SystemCertPool,
		"Certificate":func(a ...interface{}) *x509.Certificate {if len(a) == 0 {return new(x509.Certificate)};inf:=a[0];if t, ok := inf.(*x509.Certificate); ok {return t}else if t, ok := inf.(x509.Certificate); ok {return &t};return (*x509.Certificate)(nil)},
		"ParseCertificate":x509.ParseCertificate,
		"CertificateRequest":func(a ...interface{}) *x509.CertificateRequest {if len(a) == 0 {return new(x509.CertificateRequest)};inf:=a[0];if t, ok := inf.(*x509.CertificateRequest); ok {return t}else if t, ok := inf.(x509.CertificateRequest); ok {return &t};return (*x509.CertificateRequest)(nil)},
		"ParseCertificateRequest":x509.ParseCertificateRequest,
		"KeyUsage":func(KeyUsage int) x509.KeyUsage {return x509.KeyUsage(KeyUsage)},
		"PEMCipher":func(PEMCipher int) x509.PEMCipher {return x509.PEMCipher(PEMCipher)},
		"PublicKeyAlgorithm":func(PublicKeyAlgorithm int) x509.PublicKeyAlgorithm {return x509.PublicKeyAlgorithm(PublicKeyAlgorithm)},
		"SignatureAlgorithm":func(SignatureAlgorithm int) x509.SignatureAlgorithm {return x509.SignatureAlgorithm(SignatureAlgorithm)},
		"VerifyOptions":func(a ...interface{}) *x509.VerifyOptions {if len(a) == 0 {return new(x509.VerifyOptions)};inf:=a[0];if t, ok := inf.(*x509.VerifyOptions); ok {return t}else if t, ok := inf.(x509.VerifyOptions); ok {return &t};return (*x509.VerifyOptions)(nil)},
	},
	"crypto/x509/pkix":{
		"AlgorithmIdentifier":func(a ...interface{}) *pkix.AlgorithmIdentifier {if len(a) == 0 {return new(pkix.AlgorithmIdentifier)};inf:=a[0];if t, ok := inf.(*pkix.AlgorithmIdentifier); ok {return t}else if t, ok := inf.(pkix.AlgorithmIdentifier); ok {return &t};return (*pkix.AlgorithmIdentifier)(nil)},
		"AttributeTypeAndValue":func(a ...interface{}) *pkix.AttributeTypeAndValue {if len(a) == 0 {return new(pkix.AttributeTypeAndValue)};inf:=a[0];if t, ok := inf.(*pkix.AttributeTypeAndValue); ok {return t}else if t, ok := inf.(pkix.AttributeTypeAndValue); ok {return &t};return (*pkix.AttributeTypeAndValue)(nil)},
		"AttributeTypeAndValueSET":func(a ...interface{}) *pkix.AttributeTypeAndValueSET {if len(a) == 0 {return new(pkix.AttributeTypeAndValueSET)};inf:=a[0];if t, ok := inf.(*pkix.AttributeTypeAndValueSET); ok {return t}else if t, ok := inf.(pkix.AttributeTypeAndValueSET); ok {return &t};return (*pkix.AttributeTypeAndValueSET)(nil)},
		"CertificateList":func(a ...interface{}) *pkix.CertificateList {if len(a) == 0 {return new(pkix.CertificateList)};inf:=a[0];if t, ok := inf.(*pkix.CertificateList); ok {return t}else if t, ok := inf.(pkix.CertificateList); ok {return &t};return (*pkix.CertificateList)(nil)},
		"Extension":func(a ...interface{}) *pkix.Extension {if len(a) == 0 {return new(pkix.Extension)};inf:=a[0];if t, ok := inf.(*pkix.Extension); ok {return t}else if t, ok := inf.(pkix.Extension); ok {return &t};return (*pkix.Extension)(nil)},
		"Name":func(a ...interface{}) *pkix.Name {if len(a) == 0 {return new(pkix.Name)};inf:=a[0];if t, ok := inf.(*pkix.Name); ok {return t}else if t, ok := inf.(pkix.Name); ok {return &t};return (*pkix.Name)(nil)},
		"RDNSequence":func(RDNSequence []pkix.RelativeDistinguishedNameSET) pkix.RDNSequence {return RDNSequence},
		"RelativeDistinguishedNameSET":func(RelativeDistinguishedNameSET []pkix.AttributeTypeAndValue) pkix.RelativeDistinguishedNameSET {return RelativeDistinguishedNameSET},
		"RevokedCertificate":func(a ...interface{}) *pkix.RevokedCertificate {if len(a) == 0 {return new(pkix.RevokedCertificate)};inf:=a[0];if t, ok := inf.(*pkix.RevokedCertificate); ok {return t}else if t, ok := inf.(pkix.RevokedCertificate); ok {return &t};return (*pkix.RevokedCertificate)(nil)},
		"TBSCertificateList":func(a ...interface{}) *pkix.TBSCertificateList {if len(a) == 0 {return new(pkix.TBSCertificateList)};inf:=a[0];if t, ok := inf.(*pkix.TBSCertificateList); ok {return t}else if t, ok := inf.(pkix.TBSCertificateList); ok {return &t};return (*pkix.TBSCertificateList)(nil)},
	},
	"crypto/sha1":{
		"New":sha1.New,
		"Sum":sha1.Sum,
	},
	"crypto/sha256":{
		"New":sha256.New,
		"New224":sha256.New224,
		"Sum224":sha256.Sum224,
		"Sum256":sha256.Sum256,
	},
	"crypto/sha512":{
		"New":sha512.New,
		"New384":sha512.New384,
		"New512_224":sha512.New512_224,
		"New512_256":sha512.New512_256,
		"Sum384":sha512.Sum384,
		"Sum512":sha512.Sum512,
		"Sum512_224":sha512.Sum512_224,
		"Sum512_256":sha512.Sum512_256,
	},
	"encoding/asn1":{
		"MarshalWithParams":asn1.MarshalWithParams,
		"Marshal":asn1.Marshal,
		"Unmarshal":asn1.Unmarshal,
		"UnmarshalWithParams":asn1.UnmarshalWithParams,
		"BitString":func(a ...interface{}) *asn1.BitString {if len(a) == 0 {return new(asn1.BitString)};inf:=a[0];if t, ok := inf.(*asn1.BitString); ok {return t}else if t, ok := inf.(asn1.BitString); ok {return &t};return (*asn1.BitString)(nil)},
		"Flag":func(Flag bool) asn1.Flag {return asn1.Flag(Flag)},
		"ObjectIdentifier":func(ObjectIdentifier []int) asn1.ObjectIdentifier {return ObjectIdentifier},
		"RawContent":func(RawContent []byte) asn1.RawContent {return RawContent},
		"RawValue":func(a ...interface{}) *asn1.RawValue {if len(a) == 0 {return new(asn1.RawValue)};inf:=a[0];if t, ok := inf.(*asn1.RawValue); ok {return t}else if t, ok := inf.(asn1.RawValue); ok {return &t};return (*asn1.RawValue)(nil)},
	},
	"math/big":{
		"Jacobi":big.Jacobi,
		"Accuracy":func(Accuracy int8) big.Accuracy {return big.Accuracy(Accuracy)},
		"Float":func(a ...interface{}) *big.Float {if len(a) == 0 {return new(big.Float)};inf:=a[0];if t, ok := inf.(*big.Float); ok {return t}else if t, ok := inf.(big.Float); ok {return &t};return (*big.Float)(nil)},
		"NewFloat":big.NewFloat,
		"ParseFloat":big.ParseFloat,
		"Int":func(a ...interface{}) *big.Int {if len(a) == 0 {return new(big.Int)};inf:=a[0];if t, ok := inf.(*big.Int); ok {return t}else if t, ok := inf.(big.Int); ok {return &t};return (*big.Int)(nil)},
		"NewInt":big.NewInt,
		"Rat":func(a ...interface{}) *big.Rat {if len(a) == 0 {return new(big.Rat)};inf:=a[0];if t, ok := inf.(*big.Rat); ok {return t}else if t, ok := inf.(big.Rat); ok {return &t};return (*big.Rat)(nil)},
		"NewRat":big.NewRat,
		"RoundingMode":func(RoundingMode byte) big.RoundingMode {return big.RoundingMode(RoundingMode)},
		"Word":func(Word uint) big.Word {return big.Word(Word)},
	},
	"bufio":{
		"ScanBytes":bufio.ScanBytes,
		"ScanLines":bufio.ScanLines,
		"ScanRunes":bufio.ScanRunes,
		"ScanWords":bufio.ScanWords,
		"ReadWriter":func(a ...interface{}) *bufio.ReadWriter {if len(a) == 0 {return new(bufio.ReadWriter)};inf:=a[0];if t, ok := inf.(*bufio.ReadWriter); ok {return t}else if t, ok := inf.(bufio.ReadWriter); ok {return &t};return (*bufio.ReadWriter)(nil)},
		"NewReadWriter":bufio.NewReadWriter,
		"Reader":func(a ...interface{}) *bufio.Reader {if len(a) == 0 {return new(bufio.Reader)};inf:=a[0];if t, ok := inf.(*bufio.Reader); ok {return t}else if t, ok := inf.(bufio.Reader); ok {return &t};return (*bufio.Reader)(nil)},
		"NewReader":bufio.NewReader,
		"NewReaderSize":bufio.NewReaderSize,
		"Writer":func(a ...interface{}) *bufio.Writer {if len(a) == 0 {return new(bufio.Writer)};inf:=a[0];if t, ok := inf.(*bufio.Writer); ok {return t}else if t, ok := inf.(bufio.Writer); ok {return &t};return (*bufio.Writer)(nil)},
		"NewWriter":bufio.NewWriter,
		"NewWriterSize":bufio.NewWriterSize,
		"Scanner":func(a ...interface{}) *bufio.Scanner {if len(a) == 0 {return new(bufio.Scanner)};inf:=a[0];if t, ok := inf.(*bufio.Scanner); ok {return t}else if t, ok := inf.(bufio.Scanner); ok {return &t};return (*bufio.Scanner)(nil)},
		"SplitFunc":func(SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)) bufio.SplitFunc {return bufio.SplitFunc(SplitFunc)},
		"NewScanner":bufio.NewScanner,
	},
	"url":{
		"PathEscape":url.PathEscape,
		"PathUnescape":url.PathUnescape,
		"QueryEscape":url.QueryEscape,
		"QueryUnescape":url.QueryUnescape,
		"URL":func(a ...interface{}) *url.URL {if len(a) == 0 {return new(url.URL)};inf:=a[0];if t, ok := inf.(*url.URL); ok {return t}else if t, ok := inf.(url.URL); ok {return &t};return (*url.URL)(nil)},
		"Parse":url.Parse,
		"ParseRequestURI":url.ParseRequestURI,
		"Userinfo":func(a ...interface{}) *url.Userinfo {if len(a) == 0 {return new(url.Userinfo)};inf:=a[0];if t, ok := inf.(*url.Userinfo); ok {return t}else if t, ok := inf.(url.Userinfo); ok {return &t};return (*url.Userinfo)(nil)},
		"User":url.User,
		"UserPassword":url.UserPassword,
		"Values":func(Values map[string][]string) url.Values {return Values},
		"ParseQuery":url.ParseQuery,
	},
    "strings":{
    	"ReplaceAll":strings.ReplaceAll,
    	"Compare":strings.Compare,
        "Contains":strings.Contains,
        "ContainsAny":strings.ContainsAny,
        "ContainsRune":strings.ContainsRune,
        "Count":strings.Count,
        "EqualFold":strings.EqualFold,
        "Fields":strings.Fields,
        "FieldsFunc":strings.FieldsFunc,
        "HasPrefix":strings.HasPrefix,
        "HasSuffix":strings.HasSuffix,
        "Index":strings.Index,
        "IndexAny":strings.IndexAny,
        "IndexByte":strings.IndexByte,
        "IndexFunc":strings.IndexFunc,
        "IndexRune":strings.IndexRune,
        "LastIndex":strings.LastIndex,
        "LastIndexAny":strings.LastIndexAny,
        "LastIndexByte":strings.LastIndexByte,
        "LastIndexFunc":strings.LastIndexFunc,
        "Map":strings.Map,
        "Repeat":strings.Repeat,
        "Replace":strings.Replace,
        "Join":strings.Join,
        "Split":strings.Split,
        "SplitN":strings.SplitN,
        "SplitAfter":strings.SplitAfter,
        "SplitAfterN":strings.SplitAfterN,
        "Title":strings.Title,
        "ToLower":strings.ToLower,
        "ToLowerSpecial":strings.ToLowerSpecial,
        "ToTitle":strings.ToTitle,
        "ToTitleSpecial":strings.ToTitleSpecial,
        "ToUpper":strings.ToUpper,
        "ToUpperSpecial":strings.ToUpperSpecial,
        "ToValidUTF8":strings.ToValidUTF8,
        "Trim":strings.Trim,
        "TrimFunc":strings.TrimFunc,
        "TrimLeft":strings.TrimLeft,
        "TrimPrefix":strings.TrimPrefix,
        "TrimLeftFunc":strings.TrimLeftFunc,
        "TrimRight":strings.TrimRight,
        "TrimSuffix":strings.TrimSuffix,
        "TrimRightFunc":strings.TrimRightFunc,
        "TrimSpace":strings.TrimSpace,
		"Reader":func(a ...interface{}) *strings.Reader {if len(a) == 0 {return new(strings.Reader)};inf:=a[0];if t, ok := inf.(*strings.Reader); ok {return t}else if t, ok := inf.(strings.Reader); ok {return &t};return (*strings.Reader)(nil)},
        "NewReader":strings.NewReader,
		"Replacer":func(a ...interface{}) *strings.Replacer {if len(a) == 0 {return new(strings.Replacer)};inf:=a[0];if t, ok := inf.(*strings.Replacer); ok {return t}else if t, ok := inf.(strings.Replacer); ok {return &t};return (*strings.Replacer)(nil)},
        "NewReplacer":strings.NewReplacer,
        "Builder":func(a ...interface{}) *strings.Builder {if len(a) == 0 {return new(strings.Builder)};inf:=a[0];if t, ok := inf.(*strings.Builder); ok {return t}else if t, ok := inf.(strings.Builder); ok {return &t};return (*strings.Builder)(nil)},
    },
    "bytes":{
    	"ReplaceAll":bytes.ReplaceAll,
        "Compare":bytes.Compare,
        "Contains":bytes.Contains,
        "ContainsAny":bytes.ContainsAny,
        "ContainsRune":bytes.ContainsRune,
        "Count":bytes.Count,
        "Equal":bytes.Equal,
        "EqualFold":bytes.EqualFold,
        "Fields":bytes.Fields,
        "FieldsFunc":bytes.FieldsFunc,
        "HasPrefix":bytes.HasPrefix,
        "HasSuffix":bytes.HasSuffix,
        "Index":bytes.Index,
        "IndexAny":bytes.IndexAny,
        "IndexByte":bytes.IndexByte,
        "IndexFunc":bytes.IndexFunc,
        "IndexRune":bytes.IndexRune,
        "LastIndex":bytes.LastIndex,
        "LastIndexAny":bytes.LastIndexAny,
        "LastIndexByte":bytes.LastIndexByte,
        "LastIndexFunc":bytes.LastIndexFunc,
        "Map":bytes.Map,
        "Repeat":bytes.Repeat,
        "Replace":bytes.Replace,
        "Runes":bytes.Runes,
        "Join":bytes.Join,
        "Split":bytes.Split,
        "SplitN":bytes.SplitN,
        "SplitAfter":bytes.SplitAfter,
        "SplitAfterN":bytes.SplitAfterN,
        "Title":bytes.Title,
        "ToLower":bytes.ToLower,
        "ToLowerSpecial":bytes.ToLowerSpecial,
        "ToTitle":bytes.ToTitle,
        "ToTitleSpecial":bytes.ToTitleSpecial,
        "ToUpper":bytes.ToUpper,
        "ToUpperSpecial":bytes.ToUpperSpecial,
        "ToValidUTF8":bytes.ToValidUTF8,
        "Trim":bytes.Trim,
        "TrimFunc":bytes.TrimFunc,
        "TrimPrefix":bytes.TrimPrefix,
        "TrimLeft":bytes.TrimLeft,
        "TrimLeftFunc":bytes.TrimLeftFunc,
        "TrimSuffix":bytes.TrimSuffix,
        "TrimRight":bytes.TrimRight,
        "TrimRightFunc":bytes.TrimRightFunc,
        "TrimSpace":bytes.TrimSpace,
		"Buffer":func(a ...interface{}) *bytes.Buffer {if len(a) == 0 {return new(bytes.Buffer)};inf:=a[0];if t, ok := inf.(*bytes.Buffer); ok {return t}else if t, ok := inf.(bytes.Buffer); ok {return &t};return (*bytes.Buffer)(nil)},
        "NewBuffer":bytes.NewBuffer,
        "NewBufferString":bytes.NewBufferString,
		"Reader":func(a ...interface{}) *bytes.Reader {if len(a) == 0 {return new(bytes.Reader)};inf:=a[0];if t, ok := inf.(*bytes.Reader); ok {return t}else if t, ok := inf.(bytes.Reader); ok {return &t};return (*bytes.Reader)(nil)},
        "NewReader":bytes.NewReader,
    },
    "strconv":{
        "AppendBool":strconv.AppendBool,
        "AppendFloat":strconv.AppendFloat,
        "AppendInt":strconv.AppendInt,
        "AppendUint":strconv.AppendUint,
        "AppendQuote":strconv.AppendQuote,
        "AppendQuoteToASCII":strconv.AppendQuoteToASCII,
        "AppendQuoteRune":strconv.AppendQuoteRune,
        "AppendQuoteRuneToASCII":strconv.AppendQuoteRuneToASCII,
        "AppendQuoteRuneToGraphic":strconv.AppendQuoteRuneToGraphic,
        "AppendQuoteToGraphic":strconv.AppendQuoteToGraphic,
        "Atoi":strconv.Atoi,
        "Itoa":strconv.Itoa,
        "CanBackquote":strconv.CanBackquote,
        "FormatBool":strconv.FormatBool,
        "FormatFloat":strconv.FormatFloat,
        "FormatInt":strconv.FormatInt,
        "FormatUint":strconv.FormatUint,
        "IsGraphic":strconv.IsGraphic,
        "IsPrint":strconv.IsPrint,
        "ParseBool":strconv.ParseBool,
        "ParseFloat":strconv.ParseFloat,
        "ParseInt":strconv.ParseInt,
        "ParseUint":strconv.ParseUint,
        "Quote":strconv.Quote,
        "QuoteToASCII":strconv.QuoteToASCII,
        "QuoteToGraphic":strconv.QuoteToGraphic,
        "QuoteRune":strconv.QuoteRune,
        "QuoteRuneToASCII":strconv.QuoteRuneToASCII,
        "QuoteRuneToGraphic":strconv.QuoteRuneToGraphic,
        "Unquote":strconv.Unquote,
        "UnquoteChar":strconv.UnquoteChar,
    },
    "encoding/json":{
		"Compact":json.Compact,
		"Indent":json.Indent,
		"HTMLEscape":json.HTMLEscape,
		"Marshal":json.Marshal,
		"MarshalIndent":json.MarshalIndent,
		"Unmarshal":json.Unmarshal,
		"NewEncoder":json.NewEncoder,
		"NewDecoder":json.NewDecoder,
		"Valid":json.Valid,
	},
    "regexp":{
        "Match":regexp.Match,
        "MatchReader":regexp.MatchReader,
        "MatchString":regexp.MatchString,
        "QuoteMeta":regexp.QuoteMeta,
        "Compile":regexp.Compile,
        "CompilePOSIX":regexp.CompilePOSIX,
    },
    "unicode":{
    	"In":unicode.In,
        "Is":unicode.Is,
        "IsControl":unicode.IsControl,
        "IsDigit":unicode.IsDigit,
        "IsGraphic":unicode.IsGraphic,
        "IsPrint":unicode.IsPrint,
        "IsLetter":unicode.IsLetter,
        "IsLower":unicode.IsLower,
        "IsTitle":unicode.IsTitle,
        "IsUpper":unicode.IsUpper,
        "IsMark":unicode.IsMark,
        "IsNumber":unicode.IsNumber,
        "IsOneOf":unicode.IsOneOf,
        "IsPunct":unicode.IsPunct,
        "IsSpace":unicode.IsSpace,
        "IsSymbol":unicode.IsSymbol,
        "SimpleFold":unicode.SimpleFold,
        "To":unicode.To,
        "ToLower":unicode.ToLower,
        "ToTitle":unicode.ToTitle,
        "ToUpper":unicode.ToUpper,
    },
    "unicode/utf8":{
        "DecodeLastRune":utf8.DecodeLastRune,
        "DecodeLastRuneInString":utf8.DecodeLastRuneInString,
        "DecodeRune":utf8.DecodeRune,
        "DecodeRuneInString":utf8.DecodeRuneInString,
        "EncodeRune":utf8.EncodeRune,
        "FullRune":utf8.FullRune,
        "FullRuneInString":utf8.FullRuneInString,
        "RuneCount":utf8.RuneCount,
        "RuneCountInString":utf8.RuneCountInString,
        "RuneLen":utf8.RuneLen,
        "RuneStart":utf8.RuneStart,
        "Valid":utf8.Valid,
        "ValidRune":utf8.ValidRune,
        "ValidString":utf8.ValidString,
    },
    "io":{
		"EOF":io.EOF,
		"Copy":io.Copy,
		"CopyBuffer":io.CopyBuffer,
		"CopyN":io.CopyN,
		"ReadAtLeast":io.ReadAtLeast,
		"ReadFull":io.ReadFull,
		"WriteString":io.WriteString,
		"Pipe":io.Pipe,
		"LimitReader":io.LimitReader,
		"MultiReader":io.MultiReader,
		"TeeReader":io.TeeReader,
		"NewSectionReader":io.NewSectionReader,
		"MultiWriter":io.MultiWriter,
    },
    "io/ioutil":{
    	"Discard":ioutil.Discard,
    	"NopCloser":ioutil.NopCloser,
        "ReadAll":ioutil.ReadAll,
        "ReadFile":ioutil.ReadFile,
        "WriteFile":ioutil.WriteFile,
    },
    "os":{
    	"IsTimeout":os.IsTimeout,
    	"IsExist":os.IsExist,
    	"IsNotExist":os.IsNotExist,
    	"IsPermission":os.IsPermission,
    	"Link":os.Link,
    	"Readlink":os.Readlink,
    	"Symlink":os.Symlink,
    	"Mkdir":os.Mkdir,
    	"MkdirAll":os.MkdirAll,
    	"TempDir":os.TempDir,
    	"Remove":os.Remove,
    	"RemoveAll":os.RemoveAll,
    	"Rename":os.Rename,
    	"Create":os.Create,
    	"NewFile":os.NewFile,
    	"Open":os.Open,
    	"OpenFile":os.OpenFile,
    	"Lstat":os.Lstat,
    	"Stat":os.Stat,
    	"Pipe":os.Pipe,
    	"FileMode":func(FileMode uint32) os.FileMode {return os.FileMode(FileMode)},
    },
    "log":{
		"Print":log.Print,
		"Printf":log.Printf,
		"Println":log.Println,
		"SetFlags":log.SetFlags,
		"Flags":log.Flags,
		"SetPrefix":log.SetPrefix,
		"Prefix":log.Prefix,
		"SetOutput":log.SetOutput,
		"Output":log.Output,
		"Writer":log.Writer,
		"Logger":func(a ...interface{}) *log.Logger {if len(a) == 0 {return new(log.Logger)};inf:=a[0];if t, ok := inf.(*log.Logger); ok {return t}else if t, ok := inf.(log.Logger); ok {return &t};return (*log.Logger)(nil)},
		"New":log.New,
    },
}